一、# 与 ##
#define Min(a, b) ((a)<=(b)?(a):(b))

1. # (stringizing 字符串化操作符)
	#define one_sharp(x) #x
	one_sharp(aaa);//  展开为字符串 "aaa"
2. ## (token-pasting 符号连接操作符)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。

二、c/c++中#include <>与#include""区别
简言之 #include <> 和 #include "" 都会在实现定义的位置查找文件，并将其包含。
区别是若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。

三、指针常量和常量指针
把const读作常量，把星号*读作指针比如：
int * const  p  就是指针常量（const pointer），指针的地址是常量
int const *  p  就是常量指针（pointer to const），指向的量是常量
以此类推。

四、C++ 虚拟继承
虚继承（Virtual Inheritance）:为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

class 派生类名:virtual 继承方式 基类名


class A{}；
class B:public virtual A{}；


五、class B : virtual public A<B>里的<>啥意思?
template <typename T>
class A 
{ 
	friend T;
	private: 
		A() {} 
		~A() {} 
}; 
class B : virtual public A<B> 
{ 
	public: 
		B() {} 
		~B() {} 
}; 
这个就把T类型声明为A的友元类，如果不用模板的话A只能有一个友元类，
如果这样用模板的话A的友元类可以动态变化的，比如我们想把 Node类设为A的友元。

六、函数指针typedef void( *Fun )( void )   //Fun的名字可以随便取。

形式1：返回类型(*函数名)(参数表)
char (*pFun)(int);
//定义一个返回类型为char，参数为int的函数
//从指针层面上理解该函数，即函数的函数名实际上是一个指针，
//该指针指向函数在内存中的首地址


形式2：typedef 返回类型(*新类型)(参数表)
typedef char (*PTRFUN)(int); 

七、虚函数与纯虚函数 在他们的子类中都可以被重写。它们的区别是:
1.虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不写基类中的此函数，纯虚函数在基类中是没有定义的，必须在子类中加以实现。
2.纯虚函数相当于接口，不能直接实例话，需要派生类来实现函数定义；
类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，这样的话，这样编译器就可以使用后期绑定来达到多态了。
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现。
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。
虚函数是为了继承接口和默认行为，
纯虚函数只是继承接口，行为必须重新定义。
