一、# 与 ##
#define Min(a, b) ((a)<=(b)?(a):(b))

1. # (stringizing 字符串化操作符)
	#define one_sharp(x) #x
	one_sharp(aaa);//  展开为字符串 "aaa"
2. ## (token-pasting 符号连接操作符)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。

二、c/c++中#include <>与#include""区别
简言之 #include <> 和 #include "" 都会在实现定义的位置查找文件，并将其包含。
区别是若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。

三、指针常量和常量指针
把const读作常量，把星号*读作指针比如：
int * const  p  就是指针常量（const pointer），指针的地址是常量
int const *  p  就是常量指针（pointer to const），指向的量是常量
以此类推。

四、C++ 虚拟继承
虚继承（Virtual Inheritance）:为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

class 派生类名:virtual 继承方式 基类名


class A{}；
class B:public virtual A{}；


五、class B : virtual public A<B>里的<>啥意思?
template <typename T>
class A 
{ 
	friend T;
	private: 
		A() {} 
		~A() {} 
}; 
class B : virtual public A<B> 
{ 
	public: 
		B() {} 
		~B() {} 
}; 
这个就把T类型声明为A的友元类，如果不用模板的话A只能有一个友元类，
如果这样用模板的话A的友元类可以动态变化的，比如我们想把 Node类设为A的友元。

六、函数指针typedef void( *Fun )( void )   //Fun的名字可以随便取。

形式1：返回类型(*函数名)(参数表)
char (*pFun)(int);
//定义一个返回类型为char，参数为int的函数
//从指针层面上理解该函数，即函数的函数名实际上是一个指针，
//该指针指向函数在内存中的首地址


形式2：typedef 返回类型(*新类型)(参数表)
typedef char (*PTRFUN)(int); 

七、虚函数与纯虚函数 在他们的子类中都可以被重写。它们的区别是:
1.虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不写基类中的此函数，纯虚函数在基类中是没有定义的，必须在子类中加以实现。
2.纯虚函数相当于接口，不能直接实例话，需要派生类来实现函数定义；
类里声明为虚函数的话,这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被重载，这样的话，这样编译器就可以使用后期绑定来达到多态了。
纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现。
带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。
虚函数是为了继承接口和默认行为，
纯虚函数只是继承接口，行为必须重新定义。

八、typedef和define有什么区别
用法不同: typedef用来定义一种数据类型的别名, 增强程序的可读性; define主要用来定义常量, 以及书写复杂使用频繁的宏;
执行时间不同: typedef是编译过程的一部分, 有类型检查的功能; define是宏定义, 是预编译的部分, 其发生在编译之前, 只是简单的进行字符串的替换, 不进行类型的检查;
作用域不同: typedef有作用域限定; define不受作用域约束, 只要是在define声明后的引用都是正确的;
对指针的操作不同: typedef和define定义的指针时有很大的区别;
注意: typedef定义是语句,因为句尾要加上分号; 而define不是语句, 千万不能在句尾加分号;

九、关键字const
const用来定义一个只读的变量或对象; 主要优点:便于类型检查, 同宏定义一样可以方便地进行参数的修改和调整, 节省空间, 避免不必要的内存分配, 可为函数重载提供参考;

说明: const修饰函数参数, 是一种编程规范的要求, 便于阅读, 一看即知这个参数不能被改变, 实现时不易出错;

十、static作用：首先static的最主要功能是隐藏, 其次因为static变量存放在静态存储区, 所以它具备持久性和默认值0;隐藏, 当我们同时编译多个文件时, 所有未加static前缀的全局变量和函数都具有全局可见性, 如果加了static, 就会对其它源文件隐藏;

十一、如何避免“野指针"
"野指针"产生原因及解决办法如下:

指针变量声明时没有被初始化; 解决办法: 指针声明时初始化, 可以是具体的地址值, 也可让它指向NULL;
指针 p 被 free 或者 delete 之后, 没有置为 NULL; 解决办法: 指针指向的内存空间被释放后指针应该指向NULL;
指针操作超越了变量的作用范围; 解决办法: 在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL;


十二、常引用

用const声明的引用就是常引用。常引用所引用的对象不能被更改
const 类型说明符 &引用名。
void show(const double& r);

十三、指针和引用主要区别
指针是一个实体, 而引用仅是个别名;
引用使用时无需解引用(*), 指针需要解引用;
引用初始化以后不能被改变, 指针可以改变所指的对象;
引用必须被初始化, 指针不声明时初始化;
引用不能为空, 指针可以为空;
sizeof(引用), 得到的是所指向的变量(对象)的大小, 而sizeof(指针)得到的是指针本身(所指向的变量或对象的地址)的大小;
指针和引用的自增(++)运算意义不一样;
从内存分配上看: 程序为指针变量分配内存区域, 而引用不需要分配内存区域;
引用初始化以后不能被改变, 指针可以改变所指的对象;


十四、
构造函数能否为虚函数
构造函数不能是虚函数; 而且不能在构造函数中调用虚函数, 因为那样实际执行的是父类的对应函数, 因为自己还没有构造好; 析构函数可以是虚函数, 而且在一个复杂类结构中, 这往往是必须的; 析构函数也可以是纯虚函数, 但纯虚析构函数必须有定义体, 因为析构函数的调用是在子类中隐含的;

说明: 虚函数的动态绑定特性是实现重载的关键技术, 动态绑定根据实际的调用情况查询相应类的虚函数表, 调用相应的虚函数;

十五、给定一个整型变量a, 写两段代码, 第一个设置a的bit 3, 第二个清a的bit 3, 在以上两个操作中, 要保持其他位不变;
#include <iostream>
#include "stdio.h"

using namespace std;
#define BIT3 (0x1 << 3 )
static int a=0b00010000;
void set_bit3( void )
{
	a |= BIT3;           //将a第3位置1
}
void clr_bit3( void )
{
	a &= ~BIT3;        //将a第3位清零
}

int main()
{
printf("%x\n",a);
set_bit3();
printf("%x\n",a);
clr_bit3();
printf("%x\n",a);
return 0;
}

十六、关键字volatile有什么含意
提示编译器对象的值可能在编译器未监测到的情况下改变; volatile是一个类型修饰符, 它是被设计用来修饰被不同线程访问和修改的变量, 如果没有volatile, 基本上会导致这样的结果: 要么无法编写多线程程序, 要么编译器失去大量优化的机会, 一个定义为volatile的变量是说这变量可能会被意想不到地改变, 这样编译器就不会去假设这个变量的值了;

该单词的意思是可变的，易变的。在DSP中，一些寄存器的值的变化有两种情况：
（1）硬件上导致的变化，例如中断、ADC等；
（2）软件上的变化，例如对某个变量赋值等。
当加入了关键字volatile，则表示该变量的值可因上述两种情况而发生变化；即，对软件来说，硬件上变化的值是不可预知的，加入了该关键字，提示编译器每次读取该变量时，都要直接读取该变量地址中的寄存器！