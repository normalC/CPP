虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。
需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。 
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。

虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。
同一个类的所有对象都使用同一个虚表。 
为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。
为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。
这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。

个继承类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。
对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数


    //  这里指针操作比较混乱,在此稍微解析下:
   //  1.&b代表对象b的起始地址
    //  2.(int *)&b 强转成int *类型,为了后面取b对象的前四个字节,前四个字节是虚表指针
    //  3.*(int *)&b 取前四个字节,即vptr虚表地址
    //


    //  根据上面的解析我们知道*(int *)&b是vptr,即虚表指针.并且虚表是存放虚函数指针的
    //  所以虚表中每个元素(虚函数指针)在32位编译器下是4个字节,因此(int *)*(int *)&b
    //  这样强转后为了后面的取四个字节.所以*(int *)*(int *)&b就是虚表的第一个元素.
    //  即f()的地址.
    //  那么接下来的取第二个虚函数地址也就依次类推.  始终记着vptr指向的是一块内存,
    //  这块内存存放着虚函数地址,这块内存就是我们所说的虚表.
    //



#include <iostream>

using namespace std;

typedef void(*Fun)(void);


class Base {

     public:
            virtual void f() { cout << "Base::f" << endl; }
            virtual void g() { cout << "Base::g" << endl; }
            virtual void h() { cout << "Base::h" << endl; }
};

int main(int argc, char *argv[])
{
     /*
    b	@0x28fea4	Base
            [vptr]	_vptr.Base
                [0]	0x4029e0 <Base::f()>	void*
                [1]	0x402a14 <Base::g()>	void*
                [2]	0x402a48 <Base::h()>	void*


    1.&b代表对象b的起始地址
    2.(int *)&b 强转成int *类型,为了后面取b对象的前四个字节,前四个字节是虚表指针
    3.*(int *)&b 取前四个字节,即vptr虚表地址
     */

    Base b;
    Fun pFun = NULL;
    int *ppf;
    cout << "虚函数表地址：" << (int*)(&b)<< endl;     //0x28fea4
    ppf=(int*)*(int*)(&b);
    cout << "虚函数表 ― 第一个函数地址："<<hex<<*ppf<< endl;  //0x4029e0
    pFun = (Fun)*(ppf);
    pFun();
    ppf=(int*)*(int*)(&b)+1;
    cout << "虚函数表 ― 第二个函数地址：" <<hex<<*ppf<< endl;//0x402a14
    pFun = (Fun)*(ppf);
    pFun();
    ppf=(int*)*(int*)(&b)+2;
    cout << "虚函数表 ― 第三个函数地址：" <<hex<< *ppf<< endl;//0x402a48
    pFun = (Fun)*(ppf);
    pFun();
    return 0;

}

